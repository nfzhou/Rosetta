% https://rosettacode.org/wiki/15_puzzle_game
%
import util.

main =>
    Board = {{1,2,3,4},
             {5,6,7,8},
             {9,10,11,12},
             {13,14,15,0}},
    Goal = copy_term(Board),
    shuffle(Board),
    print_board(Board),
    play(Board,Goal).

shuffle(Board) =>
    foreach (_ in 1..1000)
        R1 = random() mod 4 + 1,
        C1 = random() mod 4 + 1,
        R2 = random() mod 4 + 1,
        C2 = random() mod 4 + 1,
        T := Board[R1,C1],
        Board[R1,C1] := Board[R2,C2],
        Board[R2,C2] := T
    end.

play(Board,Goal) =>
    printf("This puzzle is %s solvable.\n", cond(is_solvable(Board), "", "not")),
    while (Board != Goal)
        print_board(Board),
        possible_moves(Board,R0,C0,Moves),
        printf("Possible moves are: %w, 0 to exit. Your move? =>  ", Moves),
        S = read_line().strip().to_int(),
        if S == 0 then
            halt
        else
            move_hole(Board,R0,C0,S)
        end
    end,
    print_board(Board),
    println("Puzzle solved.").

is_solvable(Board) =>
    N = len(Board),
    A = {Board[R,C] : R in 1..N, C in 1..N},
    InversionCount = 0,
    foreach (I in 1..len(A)-1, J in I..len(A), A[I] != 0, A[J] != 0)
        if A[I] > A[J] then
            InversionCount := InversionCount + 1
        end
    end,
    if odd(N) then
        even(InversionCount)
    else
        nth(HPos,A,0),
        RHPos = len(A)-HPos+1,
        (even(RHPos) && odd(InversionCount)    || odd(RHPos) && even(InversionCount))
    end.

print_board(Board) =>
    N = len(Board),
    print("+----+----+----+----+\n"),
    foreach (R in 1..N)
        print("|"),
        foreach (C in 1..N)
            printf("%4d|", Board[R,C])
        end,
        nl
    end,
    println("+----+----+----+----+").

possible_moves(Board,R0,C0,Moves) =>
    N = len(Board),
    between(1,N,R0),
    between(1,N,C0),
    Board[R0,C0] == 0, !,
    NeibsOfHole = [(R1,C1) : (R1,C1) in [(R0-1,C0), (R0+1,C0), (R0,C0-1), (R0,C0+1)], R1 >= 1, R1 =< N, C1 >= 1, C1 =< N],
    Moves = sort([Board[R,C] : (R,C) in NeibsOfHole]).

move_hole(Board,R0,C0,S) =>
    N = len(Board),
    between(1,N,R),
    between(1,N,C),
    Board[R,C] == S, !,
    Board[R0,C0] := S,
    Board[R,C] := 0.
    

 
